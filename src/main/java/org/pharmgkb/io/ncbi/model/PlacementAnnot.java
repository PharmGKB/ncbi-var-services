/*
 * Variation Services
 * Services for variation data processing<p> <div style=\"font-size:1.1em;font-weight:normal\">NOTE: This service is still in beta testing mode. Please limit your request rate to 1 request/second.  dbSNP provides bulk download in VCF and JSON on the <a href=\"ftp://ftp.ncbi.nih.gov/snp/latest_release/\">FTP site</a> for users with a large number of RefSNPs (>100K) to process.</div> 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: variation-services@ncbi.nlm.nih.gov
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.pharmgkb.io.ncbi.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.pharmgkb.io.ncbi.model.SeqIdTraitByAssembly;

/**
 * Annotation about this sequence
 */
@Schema(description = "Annotation about this sequence")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2019-04-25T10:32:24.325-07:00[America/Los_Angeles]")public class PlacementAnnot {
  /**
   * The associated sequence&#x27;s type
   */
  @JsonAdapter(SeqTypeEnum.Adapter.class)
  public enum SeqTypeEnum {
    REFSEQ_CHROMOSOME("refseq_chromosome"),
    REFSEQ_CONTIG("refseq_contig"),
    GPIPE_CHROMOSOME("gpipe_chromosome"),
    CONTIG("contig"),
    REFSEQ_GENOMIC("refseq_genomic"),
    REFSEQ_MRNA("refseq_mrna"),
    REFSEQ_MRNA_PRED("refseq_mrna_pred"),
    MRNA("mrna"),
    REFSEQ_NCRNA("refseq_ncrna"),
    REFSEQ_NCRNA_PRED("refseq_ncrna_pred"),
    NCRNA("ncrna"),
    REFSEQ_PROT("refseq_prot"),
    GENBANK("genbank"),
    EMBL("embl"),
    DDBJ("ddbj");

    private String value;

    SeqTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SeqTypeEnum fromValue(String text) {
      for (SeqTypeEnum b : SeqTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SeqTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SeqTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SeqTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SeqTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }
  @SerializedName("seq_type")
  private SeqTypeEnum seqType = null;
  /**
   * The associated sequence&#x27;s molecule type
   */
  @JsonAdapter(MolTypeEnum.Adapter.class)
  public enum MolTypeEnum {
    UNKNOWN("unknown"),
    GENOMIC("genomic"),
    RNA("rna"),
    PROTEIN("protein"),
    MITOCHONDRION("mitochondrion"),
    NUCLEIC_ACID("nucleic_acid");

    private String value;

    MolTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static MolTypeEnum fromValue(String text) {
      for (MolTypeEnum b : MolTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<MolTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MolTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MolTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return MolTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }
  @SerializedName("mol_type")
  private MolTypeEnum molType = null;

  @SerializedName("seq_id_traits_by_assembly")
  private List<SeqIdTraitByAssembly> seqIdTraitsByAssembly = new ArrayList<SeqIdTraitByAssembly>();

  @SerializedName("is_aln_opposite_orientation")
  private Boolean isAlnOppositeOrientation = null;

  @SerializedName("is_mismatch")
  private Boolean isMismatch = null;
  public PlacementAnnot seqType(SeqTypeEnum seqType) {
    this.seqType = seqType;
    return this;
  }

  

  /**
  * The associated sequence&#x27;s type
  * @return seqType
  **/
  @Schema(required = true, description = "The associated sequence's type")
  public SeqTypeEnum getSeqType() {
    return seqType;
  }
  public void setSeqType(SeqTypeEnum seqType) {
    this.seqType = seqType;
  }
  public PlacementAnnot molType(MolTypeEnum molType) {
    this.molType = molType;
    return this;
  }

  

  /**
  * The associated sequence&#x27;s molecule type
  * @return molType
  **/
  @Schema(required = true, description = "The associated sequence's molecule type")
  public MolTypeEnum getMolType() {
    return molType;
  }
  public void setMolType(MolTypeEnum molType) {
    this.molType = molType;
  }
  public PlacementAnnot seqIdTraitsByAssembly(List<SeqIdTraitByAssembly> seqIdTraitsByAssembly) {
    this.seqIdTraitsByAssembly = seqIdTraitsByAssembly;
    return this;
  }

  public PlacementAnnot addSeqIdTraitsByAssemblyItem(SeqIdTraitByAssembly seqIdTraitsByAssemblyItem) {
    this.seqIdTraitsByAssembly.add(seqIdTraitsByAssemblyItem);
    return this;
  }

  /**
  * The relationships between this sequence and the genomic assemblies in which it participates (if any)
  * @return seqIdTraitsByAssembly
  **/
  @Schema(required = true, description = "The relationships between this sequence and the genomic assemblies in which it participates (if any)")
  public List<SeqIdTraitByAssembly> getSeqIdTraitsByAssembly() {
    return seqIdTraitsByAssembly;
  }
  public void setSeqIdTraitsByAssembly(List<SeqIdTraitByAssembly> seqIdTraitsByAssembly) {
    this.seqIdTraitsByAssembly = seqIdTraitsByAssembly;
  }
  public PlacementAnnot isAlnOppositeOrientation(Boolean isAlnOppositeOrientation) {
    this.isAlnOppositeOrientation = isAlnOppositeOrientation;
    return this;
  }

  

  /**
  * True if this sequence is aligned reverse to the PTLP sequence. Thus, the PTLP sequence&#x27;s is_aln_opposite_orientation attribute is always false.
  * @return isAlnOppositeOrientation
  **/
  @Schema(required = true, description = "True if this sequence is aligned reverse to the PTLP sequence. Thus, the PTLP sequence's is_aln_opposite_orientation attribute is always false.")
  public Boolean isIsAlnOppositeOrientation() {
    return isAlnOppositeOrientation;
  }
  public void setIsAlnOppositeOrientation(Boolean isAlnOppositeOrientation) {
    this.isAlnOppositeOrientation = isAlnOppositeOrientation;
  }
  public PlacementAnnot isMismatch(Boolean isMismatch) {
    this.isMismatch = isMismatch;
    return this;
  }

  

  /**
  * True if this sequence&#x27;s residues are different than the PTLP sequence at this locus.  Thus, the PTLP sequence&#x27;s is_mismatch attribute is always false.
  * @return isMismatch
  **/
  @Schema(required = true, description = "True if this sequence's residues are different than the PTLP sequence at this locus.  Thus, the PTLP sequence's is_mismatch attribute is always false.")
  public Boolean isIsMismatch() {
    return isMismatch;
  }
  public void setIsMismatch(Boolean isMismatch) {
    this.isMismatch = isMismatch;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PlacementAnnot placementAnnot = (PlacementAnnot) o;
    return Objects.equals(this.seqType, placementAnnot.seqType) &&
        Objects.equals(this.molType, placementAnnot.molType) &&
        Objects.equals(this.seqIdTraitsByAssembly, placementAnnot.seqIdTraitsByAssembly) &&
        Objects.equals(this.isAlnOppositeOrientation, placementAnnot.isAlnOppositeOrientation) &&
        Objects.equals(this.isMismatch, placementAnnot.isMismatch);
  }

  @Override
  public int hashCode() {
    return java.util.Objects.hash(seqType, molType, seqIdTraitsByAssembly, isAlnOppositeOrientation, isMismatch);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PlacementAnnot {\n");
    
    sb.append("    seqType: ").append(toIndentedString(seqType)).append("\n");
    sb.append("    molType: ").append(toIndentedString(molType)).append("\n");
    sb.append("    seqIdTraitsByAssembly: ").append(toIndentedString(seqIdTraitsByAssembly)).append("\n");
    sb.append("    isAlnOppositeOrientation: ").append(toIndentedString(isAlnOppositeOrientation)).append("\n");
    sb.append("    isMismatch: ").append(toIndentedString(isMismatch)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

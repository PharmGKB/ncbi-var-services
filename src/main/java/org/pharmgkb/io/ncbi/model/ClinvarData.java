/*
 * Variation Services
 * Services for variation data processing<p> <div style=\"font-size:1.1em;font-weight:normal\">NOTE: This service is still in beta testing mode. Please limit your request rate to 1 request/second.  dbSNP provides bulk download in VCF and JSON on the <a href=\"ftp://ftp.ncbi.nih.gov/snp/latest_release/\">FTP site</a> for users with a large number of RefSNPs (>100K) to process.</div> 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: variation-services@ncbi.nlm.nih.gov
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.pharmgkb.io.ncbi.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.pharmgkb.io.ncbi.model.ExternalRef;

/**
 * Metadata and clinical attributes for an allele in the ClinVar database. For more information about ClinVar&#x27;s data model, and ClinVar SCV/RCV accessions, see http://www.ncbi.nlm.nih.gov/clinvar/docs/help/
 */
@Schema(description = "Metadata and clinical attributes for an allele in the ClinVar database. For more information about ClinVar's data model, and ClinVar SCV/RCV accessions, see http://www.ncbi.nlm.nih.gov/clinvar/docs/help/")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2019-04-25T10:32:24.325-07:00[America/Los_Angeles]")public class ClinvarData {

  @SerializedName("accession_version")
  private String accessionVersion = null;

  @SerializedName("allele_id")
  private Integer alleleId = null;

  @SerializedName("measure_set_id")
  private Integer measureSetId = null;

  @SerializedName("variant_identifiers")
  private List<ExternalRef> variantIdentifiers = new ArrayList<ExternalRef>();

  @SerializedName("refsnp_id")
  private String refsnpId = null;

  @SerializedName("create_date")
  private String createDate = null;

  @SerializedName("update_date")
  private String updateDate = null;

  @SerializedName("last_evaluated_date")
  private String lastEvaluatedDate = null;
  /**
   * The status of the RCV
   */
  @JsonAdapter(ReviewStatusEnum.Adapter.class)
  public enum ReviewStatusEnum {
    NO_ASSERTION_PROVIDED("no_assertion_provided"),
    NO_ASSERTION_CRITERIA_PROVIDED("no_assertion_criteria_provided"),
    CRITERIA_PROVIDED_SINGLE_SUBMITTER("criteria_provided_single_submitter"),
    CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS_NO_CONFLICTS("criteria_provided_multiple_submitters_no_conflicts"),
    CRITERIA_PROVIDED_CONFLICTING_INTERPRETATIONS("criteria_provided_conflicting_interpretations"),
    REVIEWED_BY_EXPERT_PANEL("reviewed_by_expert_panel"),
    PRACTICE_GUIDELINE("practice_guideline");

    private String value;

    ReviewStatusEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ReviewStatusEnum fromValue(String text) {
      for (ReviewStatusEnum b : ReviewStatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ReviewStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReviewStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReviewStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ReviewStatusEnum.fromValue(String.valueOf(value));
      }
    }
  }
  @SerializedName("review_status")
  private ReviewStatusEnum reviewStatus = null;

  @SerializedName("disease_names")
  private List<String> diseaseNames = new ArrayList<String>();
  /**
   * Gets or Sets clinicalSignificances
   */
  @JsonAdapter(ClinicalSignificancesEnum.Adapter.class)
  public enum ClinicalSignificancesEnum {
    NOT_PROVIDED("not_provided"),
    PATHOGENIC("pathogenic"),
    LIKELY_PATHOGENIC("likely_pathogenic"),
    BENIGN("benign"),
    LIKELY_BENIGN("likely_benign"),
    DRUG_RESPONSE("drug_response"),
    CONFERS_SENSITIVITY("confers_sensitivity"),
    RISK_FACTOR("risk_factor"),
    ASSOCIATION("association"),
    PROTECTIVE("protective"),
    CONFLICTING_INTERPRETATIONS_OF_PATHOGENICITY("conflicting_interpretations_of_pathogenicity"),
    UNCERTAIN_SIGNIFICANCE("uncertain_significance"),
    AFFECTS("affects"),
    ASSOCIATION_NOT_FOUND("association_not_found"),
    OTHER("other");

    private String value;

    ClinicalSignificancesEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ClinicalSignificancesEnum fromValue(String text) {
      for (ClinicalSignificancesEnum b : ClinicalSignificancesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ClinicalSignificancesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClinicalSignificancesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClinicalSignificancesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ClinicalSignificancesEnum.fromValue(String.valueOf(value));
      }
    }
  }
  @SerializedName("clinical_significances")
  private List<ClinicalSignificancesEnum> clinicalSignificances = new ArrayList<ClinicalSignificancesEnum>();

  @SerializedName("disease_ids")
  private List<ExternalRef> diseaseIds = new ArrayList<ExternalRef>();
  /**
   * Gets or Sets origins
   */
  @JsonAdapter(OriginsEnum.Adapter.class)
  public enum OriginsEnum {
    UNKNOWN("unknown"),
    GERMLINE("germline"),
    SOMATIC("somatic"),
    DE_NOVO("de_novo"),
    INHERITED("inherited"),
    MATERNAL("maternal"),
    PATERNAL("paternal"),
    UNIPARENTAL("uniparental"),
    BIPARENTAL("biparental"),
    NOT_REPORTED("not_reported"),
    TESTED_INCONCLUSIVE("tested_inconclusive"),
    NOT_APPLICABLE("not_applicable"),
    EXPERIMENTALLY_GENERATED("experimentally_generated");

    private String value;

    OriginsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static OriginsEnum fromValue(String text) {
      for (OriginsEnum b : OriginsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<OriginsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OriginsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OriginsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return OriginsEnum.fromValue(String.valueOf(value));
      }
    }
  }
  @SerializedName("origins")
  private List<OriginsEnum> origins = new ArrayList<OriginsEnum>();

  @SerializedName("collection_method")
  private List<String> collectionMethod = new ArrayList<String>();

  @SerializedName("citations")
  private List<Integer> citations = new ArrayList<Integer>();

  @SerializedName("gene_ids")
  private List<String> geneIds = new ArrayList<String>();
  public ClinvarData accessionVersion(String accessionVersion) {
    this.accessionVersion = accessionVersion;
    return this;
  }

  

  /**
  * The ClinVar RCV record that links this particular allele to this particular phenotype.  For more information, see http://www.ncbi.nlm.nih.gov/clinvar/intro/
  * @return accessionVersion
  **/
  @Schema(required = true, description = "The ClinVar RCV record that links this particular allele to this particular phenotype.  For more information, see http://www.ncbi.nlm.nih.gov/clinvar/intro/")
  public String getAccessionVersion() {
    return accessionVersion;
  }
  public void setAccessionVersion(String accessionVersion) {
    this.accessionVersion = accessionVersion;
  }
  public ClinvarData alleleId(Integer alleleId) {
    this.alleleId = alleleId;
    return this;
  }

  

  /**
  * ClinVar&#x27;s identifier for this allele.  For more information, see http://www.ncbi.nlm.nih.gov/clinvar/docs/help/
  * @return alleleId
  **/
  @Schema(required = true, description = "ClinVar's identifier for this allele.  For more information, see http://www.ncbi.nlm.nih.gov/clinvar/docs/help/")
  public Integer getAlleleId() {
    return alleleId;
  }
  public void setAlleleId(Integer alleleId) {
    this.alleleId = alleleId;
  }
  public ClinvarData measureSetId(Integer measureSetId) {
    this.measureSetId = measureSetId;
    return this;
  }

  

  /**
  * ClinVar&#x27;s identifer for a set of variants that may influence the phenotype together, such as in a haplotype.  A measure-set aggregates together several allele_ids.
  * @return measureSetId
  **/
  @Schema(required = true, description = "ClinVar's identifer for a set of variants that may influence the phenotype together, such as in a haplotype.  A measure-set aggregates together several allele_ids.")
  public Integer getMeasureSetId() {
    return measureSetId;
  }
  public void setMeasureSetId(Integer measureSetId) {
    this.measureSetId = measureSetId;
  }
  public ClinvarData variantIdentifiers(List<ExternalRef> variantIdentifiers) {
    this.variantIdentifiers = variantIdentifiers;
    return this;
  }

  public ClinvarData addVariantIdentifiersItem(ExternalRef variantIdentifiersItem) {
    this.variantIdentifiers.add(variantIdentifiersItem);
    return this;
  }

  /**
  * External variant identifers, simliar to RefSNP numbers.  They are independent of RCV&#x27;s altogether.  They should be the same for every RCV in a RefSnp.  Formerly &#x27;source-link&#x27;.
  * @return variantIdentifiers
  **/
  @Schema(required = true, description = "External variant identifers, simliar to RefSNP numbers.  They are independent of RCV's altogether.  They should be the same for every RCV in a RefSnp.  Formerly 'source-link'.")
  public List<ExternalRef> getVariantIdentifiers() {
    return variantIdentifiers;
  }
  public void setVariantIdentifiers(List<ExternalRef> variantIdentifiers) {
    this.variantIdentifiers = variantIdentifiers;
  }
  public ClinvarData refsnpId(String refsnpId) {
    this.refsnpId = refsnpId;
    return this;
  }

  

  /**
  * The associated RefSnp ID according to ClinVar at time of dbSNP revision creation.
  * @return refsnpId
  **/
  @Schema(required = true, description = "The associated RefSnp ID according to ClinVar at time of dbSNP revision creation.")
  public String getRefsnpId() {
    return refsnpId;
  }
  public void setRefsnpId(String refsnpId) {
    this.refsnpId = refsnpId;
  }
  public ClinvarData createDate(String createDate) {
    this.createDate = createDate;
    return this;
  }

  

  /**
  * The date and time the ClinVar RCV was created
  * @return createDate
  **/
  @Schema(example = "2001-01-15T00:00Z", required = true, description = "The date and time the ClinVar RCV was created")
  public String getCreateDate() {
    return createDate;
  }
  public void setCreateDate(String createDate) {
    this.createDate = createDate;
  }
  public ClinvarData updateDate(String updateDate) {
    this.updateDate = updateDate;
    return this;
  }

  

  /**
  * The date the ClinVar RCV was last updated. If never updated, then same as create-date.
  * @return updateDate
  **/
  @Schema(example = "2001-01-15T00:00Z", required = true, description = "The date the ClinVar RCV was last updated. If never updated, then same as create-date.")
  public String getUpdateDate() {
    return updateDate;
  }
  public void setUpdateDate(String updateDate) {
    this.updateDate = updateDate;
  }
  public ClinvarData lastEvaluatedDate(String lastEvaluatedDate) {
    this.lastEvaluatedDate = lastEvaluatedDate;
    return this;
  }

  

  /**
  * The date the submitter last evaluated the clinical significance for this record.  If absent, then value not submitted by submitter.
  * @return lastEvaluatedDate
  **/
  @Schema(example = "2001-01-15T00:00Z", description = "The date the submitter last evaluated the clinical significance for this record.  If absent, then value not submitted by submitter.")
  public String getLastEvaluatedDate() {
    return lastEvaluatedDate;
  }
  public void setLastEvaluatedDate(String lastEvaluatedDate) {
    this.lastEvaluatedDate = lastEvaluatedDate;
  }
  public ClinvarData reviewStatus(ReviewStatusEnum reviewStatus) {
    this.reviewStatus = reviewStatus;
    return this;
  }

  

  /**
  * The status of the RCV
  * @return reviewStatus
  **/
  @Schema(required = true, description = "The status of the RCV")
  public ReviewStatusEnum getReviewStatus() {
    return reviewStatus;
  }
  public void setReviewStatus(ReviewStatusEnum reviewStatus) {
    this.reviewStatus = reviewStatus;
  }
  public ClinvarData diseaseNames(List<String> diseaseNames) {
    this.diseaseNames = diseaseNames;
    return this;
  }

  public ClinvarData addDiseaseNamesItem(String diseaseNamesItem) {
    this.diseaseNames.add(diseaseNamesItem);
    return this;
  }

  /**
  * Each RCV record is associated with one or more preferred disease names
  * @return diseaseNames
  **/
  @Schema(required = true, description = "Each RCV record is associated with one or more preferred disease names")
  public List<String> getDiseaseNames() {
    return diseaseNames;
  }
  public void setDiseaseNames(List<String> diseaseNames) {
    this.diseaseNames = diseaseNames;
  }
  public ClinvarData clinicalSignificances(List<ClinicalSignificancesEnum> clinicalSignificances) {
    this.clinicalSignificances = clinicalSignificances;
    return this;
  }

  public ClinvarData addClinicalSignificancesItem(ClinicalSignificancesEnum clinicalSignificancesItem) {
    this.clinicalSignificances.add(clinicalSignificancesItem);
    return this;
  }

  /**
  * The signifiances of this allele in the context of this disease
  * @return clinicalSignificances
  **/
  @Schema(required = true, description = "The signifiances of this allele in the context of this disease")
  public List<ClinicalSignificancesEnum> getClinicalSignificances() {
    return clinicalSignificances;
  }
  public void setClinicalSignificances(List<ClinicalSignificancesEnum> clinicalSignificances) {
    this.clinicalSignificances = clinicalSignificances;
  }
  public ClinvarData diseaseIds(List<ExternalRef> diseaseIds) {
    this.diseaseIds = diseaseIds;
    return this;
  }

  public ClinvarData addDiseaseIdsItem(ExternalRef diseaseIdsItem) {
    this.diseaseIds.add(diseaseIdsItem);
    return this;
  }

  /**
  * There are zero or more disease-ids per RCV
  * @return diseaseIds
  **/
  @Schema(required = true, description = "There are zero or more disease-ids per RCV")
  public List<ExternalRef> getDiseaseIds() {
    return diseaseIds;
  }
  public void setDiseaseIds(List<ExternalRef> diseaseIds) {
    this.diseaseIds = diseaseIds;
  }
  public ClinvarData origins(List<OriginsEnum> origins) {
    this.origins = origins;
    return this;
  }

  public ClinvarData addOriginsItem(OriginsEnum originsItem) {
    this.origins.add(originsItem);
    return this;
  }

  /**
  * The biological origins of the allele. Each SCV can have many values for this field and this reports their aggregate (taken from the RCV), with duplicates removed.
  * @return origins
  **/
  @Schema(required = true, description = "The biological origins of the allele. Each SCV can have many values for this field and this reports their aggregate (taken from the RCV), with duplicates removed.")
  public List<OriginsEnum> getOrigins() {
    return origins;
  }
  public void setOrigins(List<OriginsEnum> origins) {
    this.origins = origins;
  }
  public ClinvarData collectionMethod(List<String> collectionMethod) {
    this.collectionMethod = collectionMethod;
    return this;
  }

  public ClinvarData addCollectionMethodItem(String collectionMethodItem) {
    this.collectionMethod.add(collectionMethodItem);
    return this;
  }

  /**
  * How each SCV was collected.  Each SCV can have many values for this field and this reports their aggregate (taken from the RCV), with duplicates removed.
  * @return collectionMethod
  **/
  @Schema(required = true, description = "How each SCV was collected.  Each SCV can have many values for this field and this reports their aggregate (taken from the RCV), with duplicates removed.")
  public List<String> getCollectionMethod() {
    return collectionMethod;
  }
  public void setCollectionMethod(List<String> collectionMethod) {
    this.collectionMethod = collectionMethod;
  }
  public ClinvarData citations(List<Integer> citations) {
    this.citations = citations;
    return this;
  }

  public ClinvarData addCitationsItem(Integer citationsItem) {
    this.citations.add(citationsItem);
    return this;
  }

  /**
  * Set of PubMed IDs (PMIDs) associated with this RCV
  * @return citations
  **/
  @Schema(required = true, description = "Set of PubMed IDs (PMIDs) associated with this RCV")
  public List<Integer> getCitations() {
    return citations;
  }
  public void setCitations(List<Integer> citations) {
    this.citations = citations;
  }
  public ClinvarData geneIds(List<String> geneIds) {
    this.geneIds = geneIds;
    return this;
  }

  public ClinvarData addGeneIdsItem(String geneIdsItem) {
    this.geneIds.add(geneIdsItem);
    return this;
  }

  /**
  * Set of ClinVar reported genes associated with this RCV
  * @return geneIds
  **/
  @Schema(required = true, description = "Set of ClinVar reported genes associated with this RCV")
  public List<String> getGeneIds() {
    return geneIds;
  }
  public void setGeneIds(List<String> geneIds) {
    this.geneIds = geneIds;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ClinvarData clinvarData = (ClinvarData) o;
    return Objects.equals(this.accessionVersion, clinvarData.accessionVersion) &&
        Objects.equals(this.alleleId, clinvarData.alleleId) &&
        Objects.equals(this.measureSetId, clinvarData.measureSetId) &&
        Objects.equals(this.variantIdentifiers, clinvarData.variantIdentifiers) &&
        Objects.equals(this.refsnpId, clinvarData.refsnpId) &&
        Objects.equals(this.createDate, clinvarData.createDate) &&
        Objects.equals(this.updateDate, clinvarData.updateDate) &&
        Objects.equals(this.lastEvaluatedDate, clinvarData.lastEvaluatedDate) &&
        Objects.equals(this.reviewStatus, clinvarData.reviewStatus) &&
        Objects.equals(this.diseaseNames, clinvarData.diseaseNames) &&
        Objects.equals(this.clinicalSignificances, clinvarData.clinicalSignificances) &&
        Objects.equals(this.diseaseIds, clinvarData.diseaseIds) &&
        Objects.equals(this.origins, clinvarData.origins) &&
        Objects.equals(this.collectionMethod, clinvarData.collectionMethod) &&
        Objects.equals(this.citations, clinvarData.citations) &&
        Objects.equals(this.geneIds, clinvarData.geneIds);
  }

  @Override
  public int hashCode() {
    return java.util.Objects.hash(accessionVersion, alleleId, measureSetId, variantIdentifiers, refsnpId, createDate, updateDate, lastEvaluatedDate, reviewStatus, diseaseNames, clinicalSignificances, diseaseIds, origins, collectionMethod, citations, geneIds);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ClinvarData {\n");
    
    sb.append("    accessionVersion: ").append(toIndentedString(accessionVersion)).append("\n");
    sb.append("    alleleId: ").append(toIndentedString(alleleId)).append("\n");
    sb.append("    measureSetId: ").append(toIndentedString(measureSetId)).append("\n");
    sb.append("    variantIdentifiers: ").append(toIndentedString(variantIdentifiers)).append("\n");
    sb.append("    refsnpId: ").append(toIndentedString(refsnpId)).append("\n");
    sb.append("    createDate: ").append(toIndentedString(createDate)).append("\n");
    sb.append("    updateDate: ").append(toIndentedString(updateDate)).append("\n");
    sb.append("    lastEvaluatedDate: ").append(toIndentedString(lastEvaluatedDate)).append("\n");
    sb.append("    reviewStatus: ").append(toIndentedString(reviewStatus)).append("\n");
    sb.append("    diseaseNames: ").append(toIndentedString(diseaseNames)).append("\n");
    sb.append("    clinicalSignificances: ").append(toIndentedString(clinicalSignificances)).append("\n");
    sb.append("    diseaseIds: ").append(toIndentedString(diseaseIds)).append("\n");
    sb.append("    origins: ").append(toIndentedString(origins)).append("\n");
    sb.append("    collectionMethod: ").append(toIndentedString(collectionMethod)).append("\n");
    sb.append("    citations: ").append(toIndentedString(citations)).append("\n");
    sb.append("    geneIds: ").append(toIndentedString(geneIds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

/*
 * Variation Services
 * Services for variation data processing<p> <div style=\"font-size:1.1em;font-weight:normal\">NOTE: This service is still in beta testing mode. Please limit your request rate to 1 request/second.  dbSNP provides bulk download in VCF and JSON on the <a href=\"ftp://ftp.ncbi.nih.gov/snp/latest_release/\">FTP site</a> for users with a large number of RefSNPs (>100K) to process.</div> 
 *
 * OpenAPI spec version: 2.0.0
 * Contact: variation-services@ncbi.nlm.nih.gov
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.pharmgkb.io.ncbi.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.pharmgkb.io.ncbi.model.PlacementAnnot;
import org.pharmgkb.io.ncbi.model.PlacementAnnotatedAllele;

/**
 * For nucleotide placements, each allele in this placement is stored as a SPDI.  Each SPDI contains a reference sequence identifier.  For the set of alleles in SPDI syntax, they must all have the same reference sequence identifier, that matches the seq_id attribute. For protein placements, the allele is either in SPDI syntax, or gives a general description of a frameshift.
 */
@Schema(description = "For nucleotide placements, each allele in this placement is stored as a SPDI.  Each SPDI contains a reference sequence identifier.  For the set of alleles in SPDI syntax, they must all have the same reference sequence identifier, that matches the seq_id attribute. For protein placements, the allele is either in SPDI syntax, or gives a general description of a frameshift.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2019-04-25T10:32:24.325-07:00[America/Los_Angeles]")public class PlacementWithAllele {

  @SerializedName("seq_id")
  private String seqId = null;

  @SerializedName("is_ptlp")
  private Boolean isPtlp = null;

  @SerializedName("placement_annot")
  private PlacementAnnot placementAnnot = null;

  @SerializedName("alleles")
  private List<PlacementAnnotatedAllele> alleles = new ArrayList<PlacementAnnotatedAllele>();
  public PlacementWithAllele seqId(String seqId) {
    this.seqId = seqId;
    return this;
  }

  

  /**
  * The RefSeq/Genbank Accession.Version for the reference sequence
  * @return seqId
  **/
  @Schema(required = true, description = "The RefSeq/Genbank Accession.Version for the reference sequence")
  public String getSeqId() {
    return seqId;
  }
  public void setSeqId(String seqId) {
    this.seqId = seqId;
  }
  public PlacementWithAllele isPtlp(Boolean isPtlp) {
    this.isPtlp = isPtlp;
    return this;
  }

  

  /**
  * True if this placement is the preferred top level placement (PTLP) under the alignment data set which generated this RefSnp cluster
  * @return isPtlp
  **/
  @Schema(required = true, description = "True if this placement is the preferred top level placement (PTLP) under the alignment data set which generated this RefSnp cluster")
  public Boolean isIsPtlp() {
    return isPtlp;
  }
  public void setIsPtlp(Boolean isPtlp) {
    this.isPtlp = isPtlp;
  }
  public PlacementWithAllele placementAnnot(PlacementAnnot placementAnnot) {
    this.placementAnnot = placementAnnot;
    return this;
  }

  

  /**
  * Get placementAnnot
  * @return placementAnnot
  **/
  @Schema(required = true, description = "")
  public PlacementAnnot getPlacementAnnot() {
    return placementAnnot;
  }
  public void setPlacementAnnot(PlacementAnnot placementAnnot) {
    this.placementAnnot = placementAnnot;
  }
  public PlacementWithAllele alleles(List<PlacementAnnotatedAllele> alleles) {
    this.alleles = alleles;
    return this;
  }

  public PlacementWithAllele addAllelesItem(PlacementAnnotatedAllele allelesItem) {
    this.alleles.add(allelesItem);
    return this;
  }

  /**
  * A RefSnp can describe 1 to N alleles. While for the PTLP, all alleles (in SPDI syntax) are the same type and length, non-PTLP Placements (i.e. all other Placements), the allele in SPDI syntax may have different types, lengths and start positions, and in some rare cases, may not even overlap. But they are all on this placement&#x27;s Sequence.
  * @return alleles
  **/
  @Schema(required = true, description = "A RefSnp can describe 1 to N alleles. While for the PTLP, all alleles (in SPDI syntax) are the same type and length, non-PTLP Placements (i.e. all other Placements), the allele in SPDI syntax may have different types, lengths and start positions, and in some rare cases, may not even overlap. But they are all on this placement's Sequence.")
  public List<PlacementAnnotatedAllele> getAlleles() {
    return alleles;
  }
  public void setAlleles(List<PlacementAnnotatedAllele> alleles) {
    this.alleles = alleles;
  }
  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PlacementWithAllele placementWithAllele = (PlacementWithAllele) o;
    return Objects.equals(this.seqId, placementWithAllele.seqId) &&
        Objects.equals(this.isPtlp, placementWithAllele.isPtlp) &&
        Objects.equals(this.placementAnnot, placementWithAllele.placementAnnot) &&
        Objects.equals(this.alleles, placementWithAllele.alleles);
  }

  @Override
  public int hashCode() {
    return java.util.Objects.hash(seqId, isPtlp, placementAnnot, alleles);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PlacementWithAllele {\n");
    
    sb.append("    seqId: ").append(toIndentedString(seqId)).append("\n");
    sb.append("    isPtlp: ").append(toIndentedString(isPtlp)).append("\n");
    sb.append("    placementAnnot: ").append(toIndentedString(placementAnnot)).append("\n");
    sb.append("    alleles: ").append(toIndentedString(alleles)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
